# Lab Three

In today's lab we will be exploring structural variant calls. We will first walkthrough the variant calling file (VCF) format. We will then see how we can manipulate and get statistics from VCFs. We will visualize some SVs using Jbrowse2. 

First, pull the newest version of the repo from github to Sherlock.
```
cd $SCRATCH/BIOS424 #or wherever you cloned it last lab.
git pull
conda activate BIOS424
```

To look at and manipulate the vcfs, we will use a tool developed by Heng Li and co. called `bcftools`, which is included in the conda environment. Another useful command for quickly parsing VCFs is the bash command `grep`, which searches files or text for a given string or pattern.

The format of VCFs is described in detail here: https://samtools.github.io/hts-specs/VCFv4.5.pdf. Historically, VCFs were used for SNP data, but they have more recently been used to also store information on structural variants. There are some quirks with this, as obviously SVs are much more complex than SNPs.

We can first view the VCF by using a command like `less` (I wouldn't recommend `cat` as VCFs are often super long). We look at this vcf that was generated by sniffles, one of the tools we used last week. This VCF is for variants called across the entire D. melanogaster genome, which has 5 chromosomes (2L, 2R, 3L, 3R, X) (Often the Y chrom is omitted because it's highly repetitive and hard to work with, but this will definitely change as long-read tech continues to advance)
```
cd $SCRATCH/BIOS424/lab_three/vcfs
less dmel.sniffles.vcf
```
The first X lines in a VCF will start with `##`, which denotes header lines. These hold the metainfo of the file. The header can sometimes be super long, so it's worthwhile knowing how to view the file without the header.
```
# no header
bcftools view --no-header dmel.sniffles.vcf | less
# alternatively if you wanted to only view the header
bcftools view --header dmel.sniffles.vcf | less
```
Every non-header line in a VCF is one unique variant call. We can use this to find out how many SVs we have in this vcf.
```
bcftools view --no-header dmel.sniffles.vcf | wc -l
# output should be 7623
```
Remember, this VCF contains SVs across the whole genome. We can restrict our focus to variants specific genomic windows. This is a more involved operation that will require an index file for the vcf. To generate the index file, we first need a compressed version of the vcf.
```
bgzip -c dmel.sniffles.vcf > dmel.sniffles.vcf.gz
bcftools index dmel.sniffles.vcf.gz
#This will generate a file ending in .csi. This index file just needs to be in the same directory as the vcf, it will not be directly referred to in commands
```
Now we can filter to a specific region. Let's look at just the variants on chromosome 2R. (We need to specify the gzipped vcf here, because that's what the index is for)
```
bcftools view -r "2R" dmel.sniffles.vcf.gz > dmel.sniffles.2R.vcf
```
When we view the new vcf, the chromosome field will clearly show we only have variants on 2R. We can also check the number of variants, and we see that we have way fewer (1,677). You may also notice that at the end of the header there is a new header line that looks like:
```
##bcftools_viewCommand=view -r 2R dmel.sniffles.vcf.gz; #and the current date and time
```
When a vcf is modified using bcftools, the command is logged so that you can trace the history of a VCF, you can see the filtering steps I've done to this file before I uploaded it to github. Something important to note though is that the rest of the header is not updated to remove information. You can see that there are still five contigs listed in the header of the 2R vcf, even though we know we only have variants from one contig (2R) present in the file.

Now let's focus on just a specific type of structural variant. The variants types that will be found in the vcf will depend on the tool you use. You can either look up the tool's documentation or you can check the vcf's header to see which SV types are present in the file. We are specifically looking for the lines that start with `##ALT=<ID=`. In this vcf (either the full or 2R vcf), we can see that there are 5 described variant types.
```
##ALT=<ID=INS,Description="Insertion">
##ALT=<ID=DEL,Description="Deletion">
##ALT=<ID=DUP,Description="Duplication">
##ALT=<ID=INV,Description="Inversion">
##ALT=<ID=BND,Description="Breakend; Translocation">
```
The codes of these different variant types will appear in the `INFO` field, specifically in a portion that starts with `SVTYPE=`. We can use bcftools to only filter for insertions on 2R.
```
bcftools view -i 'SVTYPE="INS"' dmel.sniffles.2R.vcf | less
```
We can see how many insertions there are by using the same `wc -l` command as before. Alternatively we can leverage `grep` and the fact that each insertion call will have the text `SVTYPE=INS` in its `INFO` field. `grep` is a much more efficient command, and when dealing with really large files, its often better to use it for this kind of stuff. Either way, you should get a count of 789.
```
grep -c "SVTYPE=INS" dmel.sniffles.2R.vcf
```
Alternatively, we can filter out all insertion calls by using the `-e` flag instead of the `-i` flag. (exclude vs include)
```
bcftools view -e 'SVTYPE="INS"' dmel.sniffles.2R.vcf | less
```
We can filter by any of the tags in the `INFO` field with bcftools. Let's filter by the length of variants, getting only large ones.
```
bcftools view -i 'SVLEN > 10000' dmel.sniffles.2R.vcf | less
# We can count the different types of variants by piping that command into grep
bcftools view -i 'SVLEN > 10000' dmel.sniffles.2R.vcf | grep -c "SVTYPE=INS"
```
If we do this for deletions, we will get a count of 0. This isn't necessarily because there are 0 deletions, but because of a quirk that all deletion lengths are written as negative numbers. Our bcftools command will automatically filter out all deletions. We need to modify it to keep extremely large (magnitude) negative numbers.
```
bcftools view -i 'SVLEN > 10000 | SVLEN < -10000' dmel.sniffles.2R.vcf | grep -c "SVTYPE=DEL"
# should get 16 large deletions.
```
---
## Visualizing SVs
### With Jbrowse2
We can visualize SVs by looking at the read alignments against a reference genome using a program such as [IGV](https://igv.org/) or [Jbrowse2](https://jbrowse.org/jb2/). IGV has been around longer, and has a lot of features, but I don't think it works that well for long reads and visualizing structural variants. I think Jbrowse2 does a better job showing split mapped reads and stuff like that. Jbrowse2 requires a [reference fasta file](https://drive.google.com/file/d/1USMwJnD1jDjFSCfobywCHcDnaGkrtD04/view?usp=drive_link), [the file index](https://drive.google.com/file/d/1XyE0Y1MasaNLRIfSnQQDp2Sd2huTBMFZ/view?usp=drive_link), and a [bam file](https://drive.google.com/file/d/1U6wcP8zk-AUCseO6Io6EEGOiAiqMfpM_/view?usp=drive_link) and the [bam index](https://drive.google.com/file/d/1AgrIq7tlN3mjAja2iRhVSEfxADXLzRbt/view?usp=drive_link). 

I'm going to demonstrate using Jbrowse2 in class. You are welcome to download it on your computer, along with the dummy data provided, or you can download your own if you have it.

## Visualizing complex SVs from assemblies

As we've talked about in class, SVs can be complex and challenging to represent in vcf format. Here are some things you can do when dealing with situations like this. As an example, we'll explore variation at a locus linked with a pigmentation trait in swordtail fish, which displays considerable complexity.

### With Bandage
[Bandage](https://github.com/rrwick/Bandage) is a great tool to visualize assembly graphs. In calss I'll walk through a newly generated swordtail near-T2T genome, but given the size of the graph (diploid assembly + extra = 1.5Gb for swordtails), it's not available. Feel free to follow along with your own data. Bandage is most easily used on your personal computer.

In addition to providing an easy way to check the stats of your assembly graph and look for breaks/tangles, Bandage can implement blast searches. This is very useful if you have regions of interest you want to check. You can use genes or other elements to "barcode" your assembly graph, if you know what you think it should look like. I will show three examples here...

### With Mummer
Mummer is a pairwise aligner that works very well and fairly rapidly. It can be installed with conda.

---
Installing mummer
```
mamba install bioconda::mummer4
```

We'll be aligning these two sequences: [chr-13_h1.fa.gz](https://drive.google.com/file/d/1YNrMawPyc5IXFJLHtuA6Pdoi-6TMdHLx/view?usp=drive_link) and [chr-13_ref.fa.gz](https://drive.google.com/file/d/1QIlv7PRWHD2x9IIF44qfX40wD5qvjlOd/view?usp=drive_link). We'll be using a bash script that takes

---
Running the script
```
gunzip chr-13*fa.gz
sbatch sub_mummer_ref_asm.sh chr-13_ref.fa.gz chr-13_h1.fa.gz
```

The coords file can then be visualized using the provided R script. This is probably easiest on your laptop. The R script contains a function to plot the coordinates, which you can easily modify for your purposes.
